{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Analisando imagens de containers de forma automatizada com o Clair 1. Crie uma inst\u00e2ncia EC2 (detalhes) 1.1. Entre na p\u00e1gina do AWS EC2 no console da AWS 1.2. Clique em Launch Instance 1.3. Na barra de pesquisa, procure por BlackBelt image Clair 1.4. Selecione BlackBelt image Clair 1.5. Na aba seguinte selecione o bot\u00e3o Review and Launch 1.6. Revise os dados da inst\u00e2ncia e clique em Launch 1.7. Nesta parte voc\u00ea ver\u00e1 que para finalizar a cria\u00e7\u00e3o da inst\u00e2ncia, \u00e9 necess\u00e1rio criar ou selecionar uma chave de acesso. 1.7.1. Caso voc\u00ea j\u00e1 possua uma chave a qual tenha acesso, selecione-a para esta etapa. 1.7.2. Caso n\u00e3o tenha, selecione Create a new key pair , d\u00ea um nome para a chave e baixe-a no seu computador. 1.8. Selecione Launch Instances 1.9. Aguarde a cria\u00e7\u00e3o da inst\u00e2ncia 1.3. Ap\u00f3s a cria\u00e7\u00e3o da inst\u00e2ncia, copie o campo \"Public DNS (IPV4)\" da inst\u00e2ncia que voc\u00ea acabou de criar e cole aqui: 2. Conectando a inst\u00e2ncia que voc\u00ea acabou de criar (detalhes) 2.1. V\u00e1 at\u00e9 a pagina do AWS EC2 no console da AWS 2.2. Selecione a inst\u00e2ncia criada e clique no bot\u00e3o Connect 2.3. Copie o exemplo de conex\u00e3o que aparece na sua tela e cole aqui: 2.4. Abra o seu terminal na pasta onde a chave de acesso est\u00e1 2.5. Cole e rode o seguinte comando no seu terminal: <ssh_connect> 3. Configure o AWS CLI na sua inst\u00e2ncia (detalhes) 3.1. Com voc\u00ea logado na inst\u00e2ncia, rode o comando sudo yum update 3.2. Aguarde a instala\u00e7\u00e3o dos pacotes mais atuais da AWS 3.3. Vamos configurar as credenciais de acesso do AWS CLI. Para isso vamos acessar o IAM no console da AWS 3.4. Clique em Users e selecione um dos seus usu\u00e1rios 3.5. Clique em Security Credentials 3.6. Clique em Create access key 3.7. No Secret access key clique em show 3.8. Copie o Access key ID e cole aqui: 3.9. Copie o Secret access key e cole aqui: 3.10. Volte para o terminal e rode aws config 3.11. A primeira coisa que o aws config vai pedir \u00e9 o AWS Access key ID : <key_id> 3.12. Depois ser\u00e1 a vez do AWS Secret Access Key , cole ele no seu terminal: <key> 3.13. Agora \u00e9 a vez de selecionar a regi\u00e3o da AWS que seus servi\u00e7os ser\u00e3o lan\u00e7ados. Para esta demo, escreva us-east-1 3.14. No Default output format deixe vazio, somente pressione a tecla enter 3.15. Agora temos o AWS CLI configurado com sucesso 4. Construindo o ambiente com o AWS CloudFormation (detalhes) 4.1. Vamos copiar os templates do CloudFormation do GitHub, para isso cole no seu terminal: git clone https://github.com/aws-samples/aws-codepipeline-docker-vulnerability-scan.git cd aws-codepipeline-docker-vulnerability-scan 4.2. O primeiro CloudFormation que vamos rodar ser\u00e1 o de constru\u00e7\u00e3o do ambiente de redes, como VPCs e subnets. Para isso cole no seu terminal: aws cloudformation create-stack \\ --stack-name coreos-clair-vpc-stack \\ --template-body file://networking-template.yaml 4.3. Verifique como est\u00e1 o est\u00e1gio de cria\u00e7\u00e3o do sua primeira stack no CloudFormation com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name coreos-clair-vpc-stack 4.4. Ap\u00f3s receber o status de conclus\u00e3o do CloudFormation, vamos obter o output da stack: aws cloudformation describe-stacks \\ --stack-name coreos-clair-vpc-stack 4.5. Pegue os dados do output e salve aqui VPC: Public-subnet 1: Public-subnet 2: Private-subnet 1: Private-subnet 2: Cloud9-environment-name: 5. Construindo a imagem Docker do Clair: (detalhes) 5.1. A primeira coisa que vamos fazer \u00e9 criar um reposit\u00f3rio do ECR. Para isso, cole no seu terminal o comando abaixo: aws ecr create-repository --repository-name coreos-clair 5.2. A execu\u00e7\u00e3o do comando ir\u00e1 gerar um output no terminal. Anote os seguintes dados: ID: ( registryID ), este \u00e9 o ID de sua conta AWS) URI: ( repositoryUri ) ARN: ( repositoryArn ) 5.3. Em seguida, construa a imagem do Docker com o comando: docker build -t <ecr-uri> :latest ./coreos-clair 5.4. Por fim, fa\u00e7a o push da imagem para o reposit\u00f3rio criado no ECR: aws ecr get-login --no-include-email | bash docker push <ecr-uri> :latest 6. Fazendo o deploy do Clair usando o AWS CloudFormation: (detalhes) 6.1. Vamos executar outro CloudFormation para fazer o deploy do Clair, execute o seguinte comando no terminal : aws cloudformation create-stack \\ --stack-name coreos-clair-stack \\ --template-body file://coreos-clair/clair-template.yaml \\ --capabilities CAPABILITY_IAM \\ --parameters \\ ParameterKey=VpcId,ParameterValue= <vpc_id> \\ ParameterKey=PublicSubnets,ParameterValue= <pub_sub_1> \\\\, <su_user_id> \\ ParameterKey=PrivateSubnets,ParameterValue= <priv_sub_1> \\\\, <su_user_id> \\ ParameterKey=ECRRepositoryUri,ParameterValue= <ecr_uri> 6.2. verifique a cria\u00e7\u00e3o do CloudFormation com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name coreos-clair-stack 7. Fazendo o deploy do site de exemplo com o NGINX: (detalhes) 7.1. Vamos criar um reposit\u00f3rio do CodeCommit para armazenar o website com NGINX, para isso cole os comandos a baixo no seu terminal : 7.1.1. Crie o reposit\u00f3rio: aws codecommit create-repository --repository-name my-nginx-website cd ../ git clone <cloneUrlSsh> 7.1.2. Copie o site NGINX do rep\u00f3sit\u00f3rio: cp -R aws-codepipeline-docker-vulnerability-scan/nginx-website/* my-nginx-website/ 7.1.3. Fa\u00e7a os comentarios da sua altera\u00e7\u00e3o, e envie-lo: cd my-nginx-wecd mybsite/ git add * git commit -m \"Initial commit\" git push 7.2. Agora, criaremos um reposit\u00f3rio para hospedar a imagem do site NGINX: 7.2.1. Crie o reposit\u00f3rio: aws ecr create-repository --repository-name nginx-website 7.2.2. Construindo a imagem do docker docker build -f Dockerfile-amznlinux -t <ecr_uri> /nginx-website:latest . 7.2.3. Envie a imagem do docker para o reposit\u00f3rio: docker push <ecr_uri> /nginx-website:latest 7.3. Ent\u00e3o, vamos fazer o deploy do site NGINX usando o AWS CloudFormation . Coloque no seu terminal os comandos a seguir: 7.3.1. Volte uma pasta na sua instancia: cd ../aws-codepipeline-docker-vulnerability-scan/ 7.3.2. Cole no seu terminal todas as linhas abaixo, para a cria\u00e7\u00e3o dos recursos via CloudFormation : aws cloudformation create-stack \\ --stack-name nginx-website-stack \\ --stack-name coreos-clair-stack \\ --template-body file://nginx-website/nginx-website-template.yaml \\ --capabilities CAPABILITY_IAM \\ --parameters \\ ParameterKey=VpcId,ParameterValue= <vpc_id> \\ ParameterKey=PublicSubnets,ParameterValue= <pub_sub_1> \\\\, <su_user_id> \\ ParameterKey=PrivateSubnets,ParameterValue= <priv_sub_1> \\\\, <su_user_id> \\ ParameterKey=ECRRepositoryUri,ParameterValue= <ecr_uri> 7.3.3. Verifique se a constru\u00e7\u00e3o do CloudFormation foi feita com sucesso, com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name nginx-website-stack 7.3.4. Pegue os outputs do CloudFormation que acabamos de criar colocando os seguintes comandos no seu terminal: aws cloudformation describe-stacks \\ --stack-name nginx-website-stack \\ --query 'Stacks[].Outputs[]' 7.3.5. Cole aqui os dois outputs do CloudFormation que acabamos de criar: A url do seu loadbalancer : O nome do seu service do ECS : 8. Criando o pipeline (detalhes) 8.1. Vamos Criar um CloudFormation para criar o pipeline com o Clair. O template a seguir cria um projeto no CodBuild, um pipeline no ColdPipeline, ua regra no Amazon CloudWatch Events e as permiss\u00f5es necess\u00e1rias pelo IAM. 8.2. Cole no seu terminal os comandos abaixo para a cria\u00e7\u00e3o da stack no CloudFormation aws cloudformation create-stack \\ --stack-name nginx-website-codepipeline-stack \\ --template-body file://clair-codepipeline-template.yaml \\ --capabilities CAPABILITY_IAM \\ --disable-rollback \\ --parameters \\ ParameterKey=EcrRepositoryArn,ParameterValue= <ecr_arn> /nginx-website \\ ParameterKey=EcrRepositoryUri,ParameterValue= <ecr_uri> /nginx-website \\ ParameterKey=ClairAlbDnsName,ParameterValue= <nginx_url> \\ ParameterKey=EcsServiceName,ParameterValue= <ecs_name> \\ ParameterKey=NginxWebsiteCodeCommitRepoArn,ParameterValue= <codecommit_repo_arn> 9. Verificando os resultados no CloudWatch Logs (detalhes) 9.1. Acesse o CloudWatch Logs no console da AWS 9.2. Entre na sess\u00e3o de Logs , no menu a esquerda 9.3. Selecione o /aws/codebuild/nginx-codeBuild-project , para que voc\u00ea possa fazer a analise 9.4. L\u00e1 fica salvo todos os logs dentro das pastas, l\u00e1 se pode verificar todas as vunerabilidades que foram encontradas pelo Clair.","title":"Home"},{"location":"#analisando-imagens-de-containers-de-forma-automatizada-com-o-clair","text":"","title":"Analisando imagens de containers de forma automatizada com o Clair"},{"location":"#1-crie-uma-instancia-ec2","text":"(detalhes) 1.1. Entre na p\u00e1gina do AWS EC2 no console da AWS 1.2. Clique em Launch Instance 1.3. Na barra de pesquisa, procure por BlackBelt image Clair 1.4. Selecione BlackBelt image Clair 1.5. Na aba seguinte selecione o bot\u00e3o Review and Launch 1.6. Revise os dados da inst\u00e2ncia e clique em Launch 1.7. Nesta parte voc\u00ea ver\u00e1 que para finalizar a cria\u00e7\u00e3o da inst\u00e2ncia, \u00e9 necess\u00e1rio criar ou selecionar uma chave de acesso. 1.7.1. Caso voc\u00ea j\u00e1 possua uma chave a qual tenha acesso, selecione-a para esta etapa. 1.7.2. Caso n\u00e3o tenha, selecione Create a new key pair , d\u00ea um nome para a chave e baixe-a no seu computador. 1.8. Selecione Launch Instances 1.9. Aguarde a cria\u00e7\u00e3o da inst\u00e2ncia 1.3. Ap\u00f3s a cria\u00e7\u00e3o da inst\u00e2ncia, copie o campo \"Public DNS (IPV4)\" da inst\u00e2ncia que voc\u00ea acabou de criar e cole aqui:","title":"1. Crie uma inst\u00e2ncia EC2"},{"location":"#2-conectando-a-instancia-que-voce-acabou-de-criar","text":"(detalhes) 2.1. V\u00e1 at\u00e9 a pagina do AWS EC2 no console da AWS 2.2. Selecione a inst\u00e2ncia criada e clique no bot\u00e3o Connect 2.3. Copie o exemplo de conex\u00e3o que aparece na sua tela e cole aqui: 2.4. Abra o seu terminal na pasta onde a chave de acesso est\u00e1 2.5. Cole e rode o seguinte comando no seu terminal: <ssh_connect>","title":"2. Conectando a inst\u00e2ncia que voc\u00ea acabou de criar"},{"location":"#3-configure-o-aws-cli-na-sua-instancia","text":"(detalhes) 3.1. Com voc\u00ea logado na inst\u00e2ncia, rode o comando sudo yum update 3.2. Aguarde a instala\u00e7\u00e3o dos pacotes mais atuais da AWS 3.3. Vamos configurar as credenciais de acesso do AWS CLI. Para isso vamos acessar o IAM no console da AWS 3.4. Clique em Users e selecione um dos seus usu\u00e1rios 3.5. Clique em Security Credentials 3.6. Clique em Create access key 3.7. No Secret access key clique em show 3.8. Copie o Access key ID e cole aqui: 3.9. Copie o Secret access key e cole aqui: 3.10. Volte para o terminal e rode aws config 3.11. A primeira coisa que o aws config vai pedir \u00e9 o AWS Access key ID : <key_id> 3.12. Depois ser\u00e1 a vez do AWS Secret Access Key , cole ele no seu terminal: <key> 3.13. Agora \u00e9 a vez de selecionar a regi\u00e3o da AWS que seus servi\u00e7os ser\u00e3o lan\u00e7ados. Para esta demo, escreva us-east-1 3.14. No Default output format deixe vazio, somente pressione a tecla enter 3.15. Agora temos o AWS CLI configurado com sucesso","title":"3. Configure o AWS CLI na sua inst\u00e2ncia"},{"location":"#4-construindo-o-ambiente-com-o-aws-cloudformation","text":"(detalhes) 4.1. Vamos copiar os templates do CloudFormation do GitHub, para isso cole no seu terminal: git clone https://github.com/aws-samples/aws-codepipeline-docker-vulnerability-scan.git cd aws-codepipeline-docker-vulnerability-scan 4.2. O primeiro CloudFormation que vamos rodar ser\u00e1 o de constru\u00e7\u00e3o do ambiente de redes, como VPCs e subnets. Para isso cole no seu terminal: aws cloudformation create-stack \\ --stack-name coreos-clair-vpc-stack \\ --template-body file://networking-template.yaml 4.3. Verifique como est\u00e1 o est\u00e1gio de cria\u00e7\u00e3o do sua primeira stack no CloudFormation com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name coreos-clair-vpc-stack 4.4. Ap\u00f3s receber o status de conclus\u00e3o do CloudFormation, vamos obter o output da stack: aws cloudformation describe-stacks \\ --stack-name coreos-clair-vpc-stack 4.5. Pegue os dados do output e salve aqui VPC: Public-subnet 1: Public-subnet 2: Private-subnet 1: Private-subnet 2: Cloud9-environment-name:","title":"4. Construindo o ambiente com o AWS CloudFormation"},{"location":"#5-construindo-a-imagem-docker-do-clair","text":"(detalhes) 5.1. A primeira coisa que vamos fazer \u00e9 criar um reposit\u00f3rio do ECR. Para isso, cole no seu terminal o comando abaixo: aws ecr create-repository --repository-name coreos-clair 5.2. A execu\u00e7\u00e3o do comando ir\u00e1 gerar um output no terminal. Anote os seguintes dados: ID: ( registryID ), este \u00e9 o ID de sua conta AWS) URI: ( repositoryUri ) ARN: ( repositoryArn ) 5.3. Em seguida, construa a imagem do Docker com o comando: docker build -t <ecr-uri> :latest ./coreos-clair 5.4. Por fim, fa\u00e7a o push da imagem para o reposit\u00f3rio criado no ECR: aws ecr get-login --no-include-email | bash docker push <ecr-uri> :latest","title":"5. Construindo a imagem Docker do Clair:"},{"location":"#6-fazendo-o-deploy-do-clair-usando-o-aws-cloudformation","text":"(detalhes) 6.1. Vamos executar outro CloudFormation para fazer o deploy do Clair, execute o seguinte comando no terminal : aws cloudformation create-stack \\ --stack-name coreos-clair-stack \\ --template-body file://coreos-clair/clair-template.yaml \\ --capabilities CAPABILITY_IAM \\ --parameters \\ ParameterKey=VpcId,ParameterValue= <vpc_id> \\ ParameterKey=PublicSubnets,ParameterValue= <pub_sub_1> \\\\, <su_user_id> \\ ParameterKey=PrivateSubnets,ParameterValue= <priv_sub_1> \\\\, <su_user_id> \\ ParameterKey=ECRRepositoryUri,ParameterValue= <ecr_uri> 6.2. verifique a cria\u00e7\u00e3o do CloudFormation com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name coreos-clair-stack","title":"6. Fazendo o deploy do Clair usando o AWS CloudFormation:"},{"location":"#7-fazendo-o-deploy-do-site-de-exemplo-com-o-nginx","text":"(detalhes) 7.1. Vamos criar um reposit\u00f3rio do CodeCommit para armazenar o website com NGINX, para isso cole os comandos a baixo no seu terminal : 7.1.1. Crie o reposit\u00f3rio: aws codecommit create-repository --repository-name my-nginx-website cd ../ git clone <cloneUrlSsh> 7.1.2. Copie o site NGINX do rep\u00f3sit\u00f3rio: cp -R aws-codepipeline-docker-vulnerability-scan/nginx-website/* my-nginx-website/ 7.1.3. Fa\u00e7a os comentarios da sua altera\u00e7\u00e3o, e envie-lo: cd my-nginx-wecd mybsite/ git add * git commit -m \"Initial commit\" git push 7.2. Agora, criaremos um reposit\u00f3rio para hospedar a imagem do site NGINX: 7.2.1. Crie o reposit\u00f3rio: aws ecr create-repository --repository-name nginx-website 7.2.2. Construindo a imagem do docker docker build -f Dockerfile-amznlinux -t <ecr_uri> /nginx-website:latest . 7.2.3. Envie a imagem do docker para o reposit\u00f3rio: docker push <ecr_uri> /nginx-website:latest 7.3. Ent\u00e3o, vamos fazer o deploy do site NGINX usando o AWS CloudFormation . Coloque no seu terminal os comandos a seguir: 7.3.1. Volte uma pasta na sua instancia: cd ../aws-codepipeline-docker-vulnerability-scan/ 7.3.2. Cole no seu terminal todas as linhas abaixo, para a cria\u00e7\u00e3o dos recursos via CloudFormation : aws cloudformation create-stack \\ --stack-name nginx-website-stack \\ --stack-name coreos-clair-stack \\ --template-body file://nginx-website/nginx-website-template.yaml \\ --capabilities CAPABILITY_IAM \\ --parameters \\ ParameterKey=VpcId,ParameterValue= <vpc_id> \\ ParameterKey=PublicSubnets,ParameterValue= <pub_sub_1> \\\\, <su_user_id> \\ ParameterKey=PrivateSubnets,ParameterValue= <priv_sub_1> \\\\, <su_user_id> \\ ParameterKey=ECRRepositoryUri,ParameterValue= <ecr_uri> 7.3.3. Verifique se a constru\u00e7\u00e3o do CloudFormation foi feita com sucesso, com o comando abaixo: aws cloudformation wait stack-create-complete \\ --stack-name nginx-website-stack 7.3.4. Pegue os outputs do CloudFormation que acabamos de criar colocando os seguintes comandos no seu terminal: aws cloudformation describe-stacks \\ --stack-name nginx-website-stack \\ --query 'Stacks[].Outputs[]' 7.3.5. Cole aqui os dois outputs do CloudFormation que acabamos de criar: A url do seu loadbalancer : O nome do seu service do ECS :","title":"7. Fazendo o deploy do site de exemplo com o NGINX:"},{"location":"#8-criando-o-pipeline","text":"(detalhes) 8.1. Vamos Criar um CloudFormation para criar o pipeline com o Clair. O template a seguir cria um projeto no CodBuild, um pipeline no ColdPipeline, ua regra no Amazon CloudWatch Events e as permiss\u00f5es necess\u00e1rias pelo IAM. 8.2. Cole no seu terminal os comandos abaixo para a cria\u00e7\u00e3o da stack no CloudFormation aws cloudformation create-stack \\ --stack-name nginx-website-codepipeline-stack \\ --template-body file://clair-codepipeline-template.yaml \\ --capabilities CAPABILITY_IAM \\ --disable-rollback \\ --parameters \\ ParameterKey=EcrRepositoryArn,ParameterValue= <ecr_arn> /nginx-website \\ ParameterKey=EcrRepositoryUri,ParameterValue= <ecr_uri> /nginx-website \\ ParameterKey=ClairAlbDnsName,ParameterValue= <nginx_url> \\ ParameterKey=EcsServiceName,ParameterValue= <ecs_name> \\ ParameterKey=NginxWebsiteCodeCommitRepoArn,ParameterValue= <codecommit_repo_arn>","title":"8. Criando o pipeline"},{"location":"#9-verificando-os-resultados-no-cloudwatch-logs","text":"(detalhes) 9.1. Acesse o CloudWatch Logs no console da AWS 9.2. Entre na sess\u00e3o de Logs , no menu a esquerda 9.3. Selecione o /aws/codebuild/nginx-codeBuild-project , para que voc\u00ea possa fazer a analise 9.4. L\u00e1 fica salvo todos os logs dentro das pastas, l\u00e1 se pode verificar todas as vunerabilidades que foram encontradas pelo Clair.","title":"9. Verificando os resultados no CloudWatch Logs"}]}